《算法及数据结构》：
---Array(数组)：
	内排序------>:
	冒泡排序：
	选择排序：
	插入排序：
	希尔排序：
	快速排序：
	*堆排序：

	外排序------>:
	归并排序：
	计数排序：
	桶排序：
	基数排序：

	查找------>:
	顺序查找：
	二分查找：
	索引查找/分块查找：	

---Link(链表)：
	单向链表：
		
	双向链表：

---Tree(树)：
    二叉遍历：
		1.层序遍历
		2.中序遍历
		3.前序遍历
		4.后序遍历
	二叉树搜索：
	二叉树排序：
		
*---HashTable(哈希表/散列表)：
	冲突解决：
		1.依次顺序向后查找
		2.链表方式
		3.二叉查找树

*---Heap(堆)：
	-存储结构：
	数组:
	树:节点有额外指针开销
	升序：max heap(小根堆)
	降序：mini heap(大根堆)

*---Queue(队列)：
	loop queue(循环队列)：
	link queue(链式队列)：
	队列转栈：

*---Stack(栈)：
	(array stack)顺序栈:
	(link stack)链式栈:	
	栈转队列：

---Graph(图)：
	


《影响算法因素》：
---时间复杂度：
	 描述算法复杂度时,常用O(1), O(log n), O(n), O(n log n), O(n^2), O(n^3), O(n^n):

    	 O(1):
	 就是最低的时空复杂度了，也就是耗时/耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变。
	 哈希算法就是典型的O(1)时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）
    
	 O(log n):
	 当数据增大n倍时，耗时增大log n倍（这里的log是以2为底的，
    	 比如，当数据增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度）。
	     二分查找就是O(log n)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标。
     
         O(n):
         就代表数据量增大几倍，耗时也增大几倍。比如常见的遍历算法。

	 O(n log n):
	 就是n乘以logn，当数据增大256倍时，耗时增大256*8=2048倍。
	 这个复杂度高于线性低于平方。归并排序就是O(nlogn)的时间复杂度。
      
	 O(n^2):
	 代表数据量增大n倍时，耗时增大n的平方倍，这是比线性更高的时间复杂度。
	 比如冒泡排序，就是典型的O(n^2)的算法，对n个数排序，需要扫描n×n次。

---空间复杂度:


---排序方式:
	内排：
	外排：

---稳定性:
	稳定：
	不稳定：

